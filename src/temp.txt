        // if lit is the last literal, conflict
        if ( status == UNIT ) {
            status = CONFLICT;
            return;
        }

        auto [l1, l2] = watched_lits();
        auto& [w1, w2] = watched;
        
        if (lit != l1) {
            using std::swap;
            swap( w1, w2 );
        }

        // find unassigned literal
        for ( std::size_t i = 0; i < data.size(); ++i ) {
            lit_t l = data[i];

            if (l == l1 || l == l2) {
                continue;
            }

            // found new unassigned, adjust occurs
            if ( !asgn[std::abs(l)] ) {
                w1 = i;
                occurs[l].push_back( clause_index );
                return;
            }
        }

        // if none was found, set w1 to w2
        w1 = w2;
        lit_t l = data[w1];
        lbool v = asgn[std::abs(l)];

        // if w2 is assigned true, then the clause is sat, otherwise conflict
        if ( v ) {
            if ( *v && l > 0) {
                status = SATISFIED;
            } else {
                status = CONFLICT;
            }
        } else {
            status = UNIT;
        }
    }
